import JSZip from 'jszip';
import { saveAs } from 'file-saver';
import { ProcessedImage } from '../types';

export class ArchiveGenerator {
  async createArchive(images: ProcessedImage[], originalFileName: string): Promise<void> {
    const zip = new JSZip();
    
    // Group images by format
    const imagesByFormat = this.groupImagesByFormat(images);
    
    // Create folder structure
    Object.entries(imagesByFormat).forEach(([format, formatImages]) => {
      const folder = zip.folder(format.toUpperCase());
      
      formatImages.forEach(image => {
        folder?.file(image.name, image.blob);
      });
    });
    
    // Add README with usage instructions
    zip.file('README.md', this.generateReadme(images, originalFileName));
    
    // Generate and download archive
    const content = await zip.generateAsync({ type: 'blob' });
    const archiveName = this.getArchiveName(originalFileName);
    saveAs(content, archiveName);
  }
  
  private groupImagesByFormat(images: ProcessedImage[]): Record<string, ProcessedImage[]> {
    return images.reduce((groups, image) => {
      const format = image.name.split('.').pop()?.toUpperCase() || 'UNKNOWN';
      if (!groups[format]) {
        groups[format] = [];
      }
      groups[format].push(image);
      return groups;
    }, {} as Record<string, ProcessedImage[]>);
  }
  
  private generateReadme(images: ProcessedImage[], originalFileName: string): string {
    const totalSize = images.reduce((sum, img) => sum + img.size, 0);
    const formatCounts = images.reduce((counts, img) => {
      const format = img.name.split('.').pop()?.toUpperCase() || 'UNKNOWN';
      counts[format] = (counts[format] || 0) + 1;
      return counts;
    }, {} as Record<string, number>);
    
    return `# Image Asset Archive
    
## Original File
- **Name:** ${originalFileName}
- **Generated:** ${new Date().toISOString()}

## Archive Contents
- **Total Images:** ${images.length}
- **Total Size:** ${this.formatFileSize(totalSize)}

### Formats Included
${Object.entries(formatCounts).map(([format, count]) => `- **${format}:** ${count} images`).join('\n')}

## Usage Instructions

### HTML Implementation
\`\`\`html
<picture>
  <source srcset="AVIF/image-mobile.avif 480w,
                  AVIF/image-mobile@2x.avif 960w,
                  AVIF/image-tablet.avif 1024w,
                  AVIF/image-tablet@2x.avif 2048w"
          type="image/avif">
  <source srcset="WEBP/image-mobile.webp 480w,
                  WEBP/image-mobile@2x.webp 960w,
                  WEBP/image-tablet.webp 1024w,
                  WEBP/image-tablet@2x.webp 2048w"
          type="image/webp">
  <img src="JPEG/image-1080p.jpg"
       srcset="JPEG/image-mobile.jpg 480w,
               JPEG/image-mobile@2x.jpg 960w,
               JPEG/image-tablet.jpg 1024w,
               JPEG/image-tablet@2x.jpg 2048w"
       alt="Description of image">
</picture>
\`\`\`

### CSS Implementation
\`\`\`css
.hero-image {
  background-image: url('AVIF/image-1080p.avif');
  background-image: image-set(
    url('AVIF/image-1080p.avif') 1x,
    url('AVIF/image-1080p@2x.avif') 2x
  );
}
\`\`\`

Generated by UX Image Optimizer Tool
`;
  }
  
  private getArchiveName(originalFileName: string): string {
    const nameWithoutExt = originalFileName.replace(/\.[^/.]+$/, '');
    const timestamp = new Date().toISOString().slice(0, 16).replace(/:/g, '-');
    return `${nameWithoutExt}-assets-${timestamp}.zip`;
  }
  
  private formatFileSize(bytes: number): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }
}